<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: invert.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: invert.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// -*- coding: utf-8 -*-
import {clamp,
        mod,
        circularDelta,
        multMatrixVector} from './arithmetic.js';
import {yToMunsellValueTable} from './y-to-value-table.js';
import {lToY,
        labToLchab,
        xyzToLab,
        linearRgbToXyz,
        rgbToLinearRgb,
        rgb255ToRgb,
        hexToRgb,
        ILLUMINANT_C,
        ILLUMINANT_D65,
        SRGB} from './colorspace.js';
import {mhvcToLchab,
        mhvcToMunsell} from './convert.js';

/**
 * Converts Y of XYZ to Munsell value. The round-trip error, abs(Y -
 * munsellValueToY(yToMunsellValue(Y)), is guaranteed to be smaller than 1e-5 if
 * Y is in [0, 1].
 * @param {number} Y - will be in [0, 1]. Clamped if it exceeds the interval.
 * @returns {number} Munsell value
 */
export function yToMunsellValue(Y) {
  const y2000 = clamp(Y, 0, 1) * 2000;
  const yFloor = Math.floor(y2000);
  const yCeil = Math.ceil(y2000);
  if (yFloor === yCeil) {
    return yToMunsellValueTable[yFloor];
  } else {
    return (yCeil - y2000) * yToMunsellValueTable[yFloor] +
      (y2000 - yFloor) * yToMunsellValueTable[yCeil];
  }
}

/**
 * Converts L* of CIELAB to Munsell value. The round-trip error, abs(L* -
 * munsellValueToL(lToMunsellValue(L*)), is guaranteed to be smaller than 1e-3
 * if L* is in [0, 100].
 * @param {number} lstar - will be in [0, 100]. Clamped if it exceeds the
 * interval.
 * @returns {number} Munsell value
 */
export function lToMunsellValue(lstar) {
  return yToMunsellValue(lToY(lstar));
}

function invertMhvcToLchab (lstar, cstarab, hab, initHue100, initChroma, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  const value = lToMunsellValue(lstar);
  if (value &lt;= threshold || initChroma &lt;= threshold) {
    return [initHue100, value, initChroma];
  }
  let hue100 = initHue100;
  let chroma = initChroma;
  for (let i = 0; i &lt; maxIteration; i++) {
    const [, tmp_cstarab, tmp_hab] = mhvcToLchab(hue100, value, chroma);
    const d_cstarab = cstarab - tmp_cstarab;
    const d_hab = circularDelta(hab, tmp_hab, 360);
    const d_hue100 = d_hab * 0.277777777778; // 100/360
    const d_chroma = d_cstarab * 0.181818181818; // 1/5.5
    if (Math.abs(d_hue100) &lt;= threshold &amp;&amp;
        Math.abs(d_chroma) &lt;= threshold) {
      return [mod(hue100, 100), value, chroma];
    } else {
      hue100 += factor * d_hue100;
      chroma = Math.max(0, chroma + factor * d_chroma);
    }
  }
  // If loop finished without achieving the required accuracy:
  switch (ifReachMax) {
  case "error":
    throw new Error("invertMhvcToLchab() reached maxIteration without achieving the required accuracy.");
  case "init":
    return [initHue100, value, initChroma];
  case "last":
    return [hue100, value, chroma];
  default:
    throw new SyntaxError(`Unknown ifReachMax specifier: ${ifReachMax}`);
  }
}

/**
 * Converts LCHab to Munsell HVC by inverting {@link mhvcToLchab}() with a
 * simple iteration algorithm, which is almost the same as the one in "An
 * Open-Source Inversion Algorithm for the Munsell Renotation" by Paul Centore,
 * 2011:

 * &lt;ul>
 * &lt;li>V := {@link lToMunsellValue}(L*);&lt;/li>
 * &lt;li>C&lt;sub>0&lt;/sub> := C*&lt;sub>ab&lt;/sub> / 5.5;&lt;/li>
 * &lt;li>H&lt;sub>0&lt;/sub> := h&lt;sub>ab&lt;/sub> * 100/360;&lt;/li>
 * &lt;li>C&lt;sub>n+1&lt;/sub> := C&lt;sub>n&lt;/sub> + factor * ΔC&lt;sub>n&lt;/sub>;&lt;/li>
 * &lt;li>H&lt;sub>n+1&lt;/sub> :=  H&lt;sub>n&lt;/sub> + factor * ΔH&lt;sub>n&lt;/sub>.&lt;/li>
 * &lt;/ul>

 * &lt;p>ΔH&lt;sub>n&lt;/sub> and ΔC&lt;sub>n&lt;/sub> are internally calculated at every
 * step. This function returns Munsell HVC values if C&lt;sub>0&lt;/sub> ≦ threshold
 * or if V ≦ threshold or when max(ΔH&lt;sub>n&lt;/sub>, ΔC&lt;sub>n&lt;/sub>) falls
 * below threshold.

 * &lt;p> &lt;var>ifReachMax&lt;/var> specifies the action to be taken when the loop
 * reaches the maxIteration as follows:

 * &lt;ul>
 * &lt;li>"error": throws Error;&lt;/li>
 * &lt;li>"init": returns the initial rough approximation.&lt;/li>
 * &lt;li>"last": returns the last approximation.&lt;/li>
 * &lt;/ul>

 * Note that the given values are assumed to be under &lt;strong>Illuminant
 * C&lt;/strong>.
 * @param {number} lstar
 * @param {number} cstarab
 * @param {number} hab
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {Array} [Hue, Value, Chroma]
 */
export function lchabToMhvc(lstar, cstarab, hab, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return invertMhvcToLchab(lstar, cstarab, hab,
                           hab * 0.277777777778,
                           cstarab * 0.181818181818,
                           threshold,
                           maxIteration,
                           ifReachMax,
                           factor);
}

/**
 * Converts LCHab to Munsell string. Note that the given values are assumed to
 * be under &lt;strong>Illuminant C&lt;/strong>.
 * @param {number} lstar
 * @param {number} cstarab
 * @param {number} hab
 * @param {number} [digits = 1] - is the number of digits after the decimal
 * point. Must be non-negative integer. Note that the units digit of the hue
 * prefix is assumed to be already after the decimal point.
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {string} Munsell Color code
 * @see lchabToMhvc
 */
export function lchabToMunsell(lstar, cstarab, hab, digits = 1, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return mhvcToMunsell(...lchabToMhvc(lstar, cstarab, hab, threshold, maxIteration, ifReachMax, factor), digits);
}

/**
 * Converts CIELAB to Munsell HVC. Note that the given values are assumed to be
 * under &lt;strong>Illuminant C&lt;/strong>.
 * @param {number} lstar
 * @param {number} astar
 * @param {number} bstar
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {Array} [Hue, Value, Chroma]
 * @see lchabToMhvc
 */
export function labToMhvc(lstar, astar, bstar, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return lchabToMhvc(...labToLchab(lstar, astar, bstar), threshold, maxIteration, ifReachMax, factor);
}

/**
 * Converts CIELAB to Munsell Color string. Note that the given values are assumed to
 * be under &lt;strong>Illuminant C&lt;/strong>.
 * @param {number} lstar
 * @param {number} astar
 * @param {number} bstar
 * @param {number} [digits = 1] - is the number of digits after the decimal
 * point. Must be non-negative integer. Note that the units digit of the hue
 * prefix is assumed to be already after the decimal point.
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {string} Munsell Color code
 * @see lchabToMhvc
 */
export function labToMunsell(lstar, astar, bstar, digits = 1, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return mhvcToMunsell(...labToMhvc(lstar, astar, bstar, threshold, maxIteration, ifReachMax, factor), digits);
}

/**
 * Converts XYZ to Munsell HVC, where Bradford transformation is used as CAT.
 * @param {number} X
 * @param {number} Y
 * @param {number} Z
 * @param {Illuminant} [illuminant = ILLUMINANT_D65]
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {Array} [Hue, Value, Chroma]
 * @see lchabToMhvc
 */
export function xyzToMhvc(X, Y, Z, illuminant = ILLUMINANT_D65, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return labToMhvc(...xyzToLab(...multMatrixVector(illuminant.catMatrixThisToC,
                                                   [X, Y, Z]),
                               ILLUMINANT_C),
                   threshold,
                   maxIteration,
                   ifReachMax,
                   factor);
}

/**
 * Converts XYZ to Munsell Color string, where Bradford transformation is used
 * as CAT.
 * @param {number} X
 * @param {number} Y
 * @param {number} Z
 * @param {Illuminant} [illuminant = ILLUMINANT_D65]
 * @param {number} [digits = 1] - is the number of digits after the decimal
 * point. Must be non-negative integer. Note that the units digit of the hue
 * prefix is assumed to be already after the decimal point.
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {string} Munsell Color code
 * @see lchabToMhvc
 */
export function xyzToMunsell(X, Y, Z, illuminant = ILLUMINANT_D65, digits = 1, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return mhvcToMunsell(...xyzToMhvc(X, Y, Z, illuminant, threshold, maxIteration, ifReachMax, factor), digits);
}

/**
 * Converts linear RGB to Munsell HVC.
 * @param {number} lr - will be in [0, 1] though any real number is accepted and
 * properly processed as out-of-gamut color.
 * @param {number} lg - -
 * @param {number} lb - -
 * @param {RGBSpace} [rgbSpace = SRGB]
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {Array} [Hue, Value, Chroma]
 * @see lchabToMhvc
 */
export function linearRgbToMhvc(lr, lg, lb, rgbSpace = SRGB, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return xyzToMhvc(...linearRgbToXyz(lr, lg, lb, rgbSpace), rgbSpace.illuminant, threshold, maxIteration, ifReachMax, factor);
}

/**
 * Converts linear RGB to Munsell Color string.
 * @param {number} lr - will be in [0, 1] though any real number is accepted and
 * properly processed as out-of-gamut color.
 * @param {number} lg - -
 * @param {number} lb - -
 * @param {RGBSpace} [rgbSpace = SRGB]
 * @param {number} [digits = 1] - is the number of digits after the decimal
 * point. Must be non-negative integer. Note that the units digit of the hue
 * prefix is assumed to be already after the decimal point.
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {string} Munsell Color code
 * @see lchabToMhvc
 */
export function linearRgbToMunsell(lr, lg, lb, rgbSpace = SRGB, digits = 1, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return mhvcToMunsell(...linearRgbToMhvc(lr, lg, lb, rgbSpace, threshold, maxIteration, ifReachMax, factor), digits);
}

/**
 * Converts gamma-corrected RGB to Munsell HVC.
 * @param {number} r - will be in [0, 1] though any real number is accepted and
 * properly processed as out-of-gamut color.
 * @param {number} g - -
 * @param {number} b - -
 * @param {RGBSpace} [rgbSpace = SRGB]
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {Array} [Hue, Value, Chroma]
 * @see lchabToMhvc
 */
export function rgbToMhvc(r, g, b, rgbSpace = SRGB, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return linearRgbToMhvc(...rgbToLinearRgb(r, g, b, rgbSpace), rgbSpace, threshold, maxIteration, ifReachMax, factor);
}

/**
 * Converts gamma-corrected RGB to Munsell Color string.
 * @param {number} r - will be in [0, 1] though any real number is accepted and
 * properly processed as out-of-gamut color.
 * @param {number} g - -
 * @param {number} b - -
 * @param {RGBSpace} [rgbSpace = SRGB]
 * @param {number} [digits = 1] - is the number of digits after the decimal
 * point. Must be non-negative integer. Note that the units digit of the hue
 * prefix is assumed to be already after the decimal point.
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {string} Munsell Color code
 * @see lchabToMhvc
 */
export function rgbToMunsell(r, g, b, rgbSpace = SRGB, digits = 1, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return mhvcToMunsell(...rgbToMhvc(r, g, b, rgbSpace, threshold, maxIteration, ifReachMax, factor), digits);
}

/**
 * Converts quantized RGB to Munsell HVC. Whether this conversion succeeds or
 * not depends on the parameters though the following behaviours are guaranteed
 * and tested on Node.js:

 * &lt;p> If r255, g255, b255 are in {0, 1, ..., 255} and the other optional
 * parameters are default,

 * &lt;ol>
 * &lt;li>rgb255ToMhvc() successfully returns Munsell HVC before maxIteration&lt;/li>
 * &lt;li>and the round-trip is invariant: i.e. {@link mhvcToRgb255}(rgb255ToMhvc(r255, g255, b255)) returns [r255, g255, b255].&lt;/li>
 * &lt;/ol>

 * @param {number} r255 - will be in {0, 1, ..., 255} though any integer is
 * accepted and properly processed as out-of-gamut color.
 * @param {number} g255 - -
 * @param {number} b255 - -
 * @param {RGBSpace} [rgbSpace = SRGB]
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {Array} [Hue, Value, Chroma]
 * @see lchabToMhvc
 */
export function rgb255ToMhvc(r255, g255, b255, rgbSpace = SRGB, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return rgbToMhvc(...rgb255ToRgb(r255, g255, b255), rgbSpace, threshold, maxIteration, ifReachMax, factor);
}

/**
 * Converts quantized RGB to Munsell Color string. Whether this conversion
 * succeeds or not depends on the parameters though the following behaviours are
 * guaranteed and tested on Node.js:

 * &lt;p> If r255, g255, b255 are in {0, 1, ..., 255} and the other optional
 * parameters are default, rgb255ToMunsell() successfully returns a Munsell
 * Color string before maxIteration.

 * @param {number} r255 - will be in {0, 1, ..., 255} though any integer is
 * accepted and properly processed as out-of-gamut color.
 * @param {number} g255 - -
 * @param {number} b255 - -
 * @param {RGBSpace} [rgbSpace = SRGB]
 * @param {number} [digits = 1] - is the number of digits after the decimal
 * point. Must be non-negative integer. Note that the units digit of the hue
 * prefix is assumed to be already after the decimal point.
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {string} Munsell Color code
 * @see lchabToMhvc
 */
export function rgb255ToMunsell(r255, g255, b255, rgbSpace = SRGB, digits = 1, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return mhvcToMunsell(...rgb255ToMhvc(r255, g255, b255, rgbSpace, threshold, maxIteration, ifReachMax, factor), digits);
}

/**
 * Converts hex color to Munsell HVC. Whether this conversion succeeds or
 * not depends on the parameters though the following behaviours are guaranteed
 * and tested on Node.js:

 * &lt;p> If the optional parameters are default,

 * &lt;ol>
 * &lt;li>hexToMhvc() successfully returns Munsell HVC before maxIteration&lt;/li>
 * &lt;li>and the round-trip is invariant for 24-bit hex color: i.e. {@link mhvcToHex}(hexToMhvc(hex)) returns the same hex color.&lt;/li>
 * &lt;/ol>

 * @param {string} hex - may be 24-bit RGB (#XXXXXX), 12-bit RGB (#XXX), 32-bit
 * RGBA, (#XXXXXXXX), or 16-bit RGBA (#XXXX). Alpha channel is ignored.
 * @param {RGBSpace} [rgbSpace = SRGB]
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {Array} [Hue, Value, Chroma]
 * @see lchabToMhvc
 */
export function hexToMhvc(hex, rgbSpace = SRGB, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return rgbToMhvc(...hexToRgb(hex), rgbSpace, threshold, maxIteration, ifReachMax, factor);
}

/**
 * Converts hex color to Munsell Color string. Whether this conversion
 * succeeds or not depends on the parameters though the following behaviours are
 * guaranteed and tested on Node.js:

 * &lt;p> If the other optional parameters are default, hexToMunsell() successfully
 * returns a Munsell Color string before maxIteration.

 * @param {string} hex - may be 24-bit RGB (#XXXXXX), 12-bit RGB (#XXX), 32-bit
 * RGBA, (#XXXXXXXX), or 16-bit RGBA (#XXXX). Alpha channel is ignored.
 * @param {RGBSpace} [rgbSpace = SRGB]
 * @param {number} [digits = 1] - is the number of digits after the decimal
 * point. Must be non-negative integer. Note that the units digit of the hue
 * prefix is assumed to be already after the decimal point.
 * @param {number} [threshold = 1e-6]
 * @param {number} [maxIteration = 200]
 * @param {string} [ifReachMax = "error"]
 * @param {number} [factor = 0.5]
 * @returns {string} Munsell Color code
 * @see lchabToMhvc
 */
export function hexToMunsell(hex, rgbSpace = SRGB, digits = 1, threshold = 1e-6, maxIteration = 200, ifReachMax = "error", factor = 0.5) {
  return mhvcToMunsell(...hexToMhvc(hex, rgbSpace, threshold, maxIteration, ifReachMax, factor), digits);
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#ADOBE_RGB">ADOBE_RGB</a></li><li><a href="global.html#hexToMhvc">hexToMhvc</a></li><li><a href="global.html#hexToMunsell">hexToMunsell</a></li><li><a href="global.html#ILLUMINANT_C">ILLUMINANT_C</a></li><li><a href="global.html#ILLUMINANT_D65">ILLUMINANT_D65</a></li><li><a href="global.html#labToMhvc">labToMhvc</a></li><li><a href="global.html#labToMunsell">labToMunsell</a></li><li><a href="global.html#lchabToMhvc">lchabToMhvc</a></li><li><a href="global.html#lchabToMunsell">lchabToMunsell</a></li><li><a href="global.html#linearRgbToMhvc">linearRgbToMhvc</a></li><li><a href="global.html#linearRgbToMunsell">linearRgbToMunsell</a></li><li><a href="global.html#lToMunsellValue">lToMunsellValue</a></li><li><a href="global.html#mhvc">mhvc</a></li><li><a href="global.html#mhvcToHex">mhvcToHex</a></li><li><a href="global.html#mhvcToLab">mhvcToLab</a></li><li><a href="global.html#mhvcToLchab">mhvcToLchab</a></li><li><a href="global.html#mhvcToLinearRgb">mhvcToLinearRgb</a></li><li><a href="global.html#mhvcToMunsell">mhvcToMunsell</a></li><li><a href="global.html#mhvcToRgb">mhvcToRgb</a></li><li><a href="global.html#mhvcToRgb255">mhvcToRgb255</a></li><li><a href="global.html#mhvcToXyz">mhvcToXyz</a></li><li><a href="global.html#munsell">munsell</a></li><li><a href="global.html#munsellToHex">munsellToHex</a></li><li><a href="global.html#munsellToLab">munsellToLab</a></li><li><a href="global.html#munsellToLchab">munsellToLchab</a></li><li><a href="global.html#munsellToLinearRgb">munsellToLinearRgb</a></li><li><a href="global.html#munsellToMhvc">munsellToMhvc</a></li><li><a href="global.html#munsellToRgb">munsellToRgb</a></li><li><a href="global.html#munsellToRgb255">munsellToRgb255</a></li><li><a href="global.html#munsellToXyz">munsellToXyz</a></li><li><a href="global.html#munsellValueToL">munsellValueToL</a></li><li><a href="global.html#munsellValueToY">munsellValueToY</a></li><li><a href="global.html#rgb255ToMhvc">rgb255ToMhvc</a></li><li><a href="global.html#rgb255ToMunsell">rgb255ToMunsell</a></li><li><a href="global.html#rgbToMhvc">rgbToMhvc</a></li><li><a href="global.html#rgbToMunsell">rgbToMunsell</a></li><li><a href="global.html#SRGB">SRGB</a></li><li><a href="global.html#xyzToMhvc">xyzToMhvc</a></li><li><a href="global.html#xyzToMunsell">xyzToMunsell</a></li><li><a href="global.html#yToMunsellValue">yToMunsellValue</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sat Feb 20 2021 13:52:05 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
